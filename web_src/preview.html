<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Crash Logger</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .container {
            width: 90%;
            max-width: 800px;
            text-align: center;
        }

        h1 {
            color: #ffffff;
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .status-container {
            background-color: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 1.2em;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #status {
            font-weight: bold;
            color: #f39c12;
        }

        .controls button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin: 5px;
        }

        .controls button:hover {
            background-color: #2980b9;
        }

        .controls button:active {
            transform: scale(0.98);
        }

        .controls button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .chart-container {
            background-color: #1e1e1e;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            margin-top: 20px;
            min-height: 60vh;
            position: relative;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ESP32 Crash Logger</h1>
        <div class="status-container">
            <p>Status: <span id="status">Connecting...</span></p>
        </div>
        <div class="controls">
            <button id="startButton">Start Recording</button>
            <button id="stopButton" disabled>Stop Recording</button>
        </div>
        <div class="chart-container">
            <canvas id="crashChart"></canvas>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const statusSpan = document.getElementById('status');
            const startButton = document.getElementById('startButton');
            const stopButton = document.getElementById('stopButton');
            const crashChartCanvas = document.getElementById('crashChart');

            let ws;

            function connectWebSocket() {
                // Determine WebSocket URL based on current host
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                // In preview mode (file://), default to a placeholder or localhost
                const host = window.location.protocol === 'file:' ? '192.168.4.1' : window.location.host;
                ws = new WebSocket(`${wsProtocol}//${host}/ws`);

                ws.onopen = () => {
                    console.log('WebSocket connected');
                    statusSpan.textContent = 'Connected, awaiting commands.';
                    startButton.disabled = false;
                    stopButton.disabled = true;
                };

                ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    console.log('Message from ESP32:', message);

                    if (message.type === 'status') {
                        statusSpan.textContent = message.data;
                        if (message.data.includes('Armed')) {
                            startButton.disabled = true;
                            stopButton.disabled = false;
                        } else if (message.data.includes('Idle') || message.data.includes('Connected')) {
                            startButton.disabled = false;
                            stopButton.disabled = true;
                        }
                    } else if (message.type === 'crashData') {
                        drawSimpleChart(crashChartCanvas, message.data);
                        startButton.disabled = false; // Re-enable after crash data is displayed
                        stopButton.disabled = true;
                    }
                };

                ws.onclose = () => {
                    console.log('WebSocket disconnected, attempting to reconnect...');
                    statusSpan.textContent = 'Disconnected, reconnecting...';
                    startButton.disabled = true;
                    stopButton.disabled = true;
                    setTimeout(connectWebSocket, 3000); // Attempt to reconnect every 3 seconds
                };

                ws.onerror = (error) => {
                    console.error('WebSocket Error:', error);
                    statusSpan.textContent = 'Connection error.';
                    ws.close();
                };
            }

            function sendCommand(command) {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(command);
                } else {
                    console.warn('WebSocket not open. Cannot send command:', command);
                    statusSpan.textContent = 'Not connected. Please refresh.';
                }
            }

            startButton.addEventListener('click', () => sendCommand('START'));
            stopButton.addEventListener('click', () => sendCommand('STOP'));

            function drawSimpleChart(canvas, data) {
                // Set canvas internal dimensions to match display size for sharp rendering
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                ctx.clearRect(0, 0, width, height);

                // Find min/max for scaling
                let allValues = [...data.ax, ...data.ay, ...data.az];
                let minVal = Math.min(...allValues);
                let maxVal = Math.max(...allValues);

                // Add padding and ensure non-zero range
                let range = maxVal - minVal;
                if (range === 0) range = 1;
                minVal -= range * 0.1;
                maxVal += range * 0.1;

                // Recalculate range after padding
                range = maxVal - minVal;

                function mapY(val) {
                    return height - ((val - minVal) / range * height);
                }

                function mapX(i, total) {
                    return (i / (total - 1)) * width;
                }

                // Draw Background Grid
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                // Horizontal lines
                for (let i = 0; i <= 4; i++) {
                    let y = height * (i / 4);
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                }
                ctx.stroke();

                // Draw Zero Line if visible
                if (minVal < 0 && maxVal > 0) {
                    ctx.strokeStyle = '#666';
                    ctx.beginPath();
                    let zeroY = mapY(0);
                    ctx.moveTo(0, zeroY);
                    ctx.lineTo(width, zeroY);
                    ctx.stroke();
                }

                function plotLine(dataset, color) {
                    if (!dataset || dataset.length === 0) return;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(mapX(0, dataset.length), mapY(dataset[0]));
                    for (let i = 1; i < dataset.length; i++) {
                        ctx.lineTo(mapX(i, dataset.length), mapY(dataset[i]));
                    }
                    ctx.stroke();
                }

                plotLine(data.ax, 'rgb(255, 99, 132)'); // X - Red
                plotLine(data.ay, 'rgb(54, 162, 235)'); // Y - Blue
                plotLine(data.az, 'rgb(75, 192, 192)'); // Z - Green

                // Legend
                ctx.font = 'bold 14px sans-serif';
                ctx.fillStyle = 'rgb(255, 99, 132)'; ctx.fillText('X', 20, 30);
                ctx.fillStyle = 'rgb(54, 162, 235)'; ctx.fillText('Y', 50, 30);
                ctx.fillStyle = 'rgb(75, 192, 192)'; ctx.fillText('Z', 80, 30);

                // Y-Axis Labels (Min/Max)
                ctx.fillStyle = '#aaa';
                ctx.font = '12px sans-serif';
                ctx.fillText(maxVal.toFixed(1), 5, 15);
                ctx.fillText(minVal.toFixed(1), 5, height - 5);
            }

            // --- Simulated Data for Preview ---
            statusSpan.textContent = 'Preview - Chart data is simulated.';
            const sampleCrashData = {
                ax: [0.5, 0.6, 0.8, 2.5, 6.5, 15.8, 9.2, 4.1, 1.0, 0.4, 0.2, 0.1, 0.0, -0.1, -0.2, -0.1, 0.5, 0.6, 0.8, 2.5, 6.5, 15.8, 9.2, 4.1, 1.0, 0.4, 0.2, 0.1, 0.0, -0.1, -0.2, -0.1],
                ay: [-0.1, -0.2, -0.3, -1.8, -3.9, -5.5, -3.8, -2.0, -0.5, -0.2, -0.1, -0.1, 0.0, 0.1, 0.1, 0.0, -0.1, -0.2, -0.3, -1.8, -3.9, -5.5, -3.8, -2.0, -0.5, -0.2, -0.1, -0.1, 0.0, 0.1, 0.1, 0.0],
                az: [9.8, 9.7, 9.8, 9.9, 7.5, -5.2, 0.8, 5.0, 8.5, 9.7, 9.8, 9.9, 9.8, 9.8, 9.7, 9.8, 9.8, 9.7, 9.8, 9.9, 7.5, -5.2, 0.8, 5.0, 8.5, 9.7, 9.8, 9.9, 9.8, 9.8, 9.7, 9.8]
            };
            drawSimpleChart(crashChartCanvas, sampleCrashData);
            // --- End Simulated Data ---

            connectWebSocket(); // Initial WebSocket connection
        });
    </script>
</body>

</html>